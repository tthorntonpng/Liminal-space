<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Liminal Room Scene</title>
  <style>
    body { margin: 0; background-color: #0d1012; overflow: hidden; }
    canvas { display: block; touch-action: none; }

    .zoom-controls {
      position: fixed;
      bottom: 20px;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      z-index: 10;
    }

    .zoom-btn {
      background-color: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.5);
      color: white;
      padding: 10px 15px;
      font-size: 16px;
      border-radius: 6px;
      cursor: pointer;
      backdrop-filter: blur(4px);
      transition: background 0.2s;
    }

    .zoom-btn:hover {
      background-color: rgba(255, 255, 255, 0.25);
    }
  </style>
</head>
<body>
  <div class="zoom-controls">
    <button id="zoomIn" class="zoom-btn">üîç Zoom In</button>
    <button id="zoomOut" class="zoom-btn">üîé Zoom Out</button>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

  <script>
    // === Scene Setup ===
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0d1012);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);

    // Default zoom level
    let cameraDistance = 4.7;
    let targetDistance = cameraDistance;

    if (window.innerWidth > 800) {
      cameraDistance = 4.5; // slightly closer for desktop
      targetDistance = 4.5;
    }

    const minDistance = 2;
    const maxDistance = 7.5;
    let cameraAngle = { x: 0.3, y: -0.12 };

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    // === Lights ===
    const ambientLight = new THREE.AmbientLight(0xb0c4de, 0.35);
    scene.add(ambientLight);

    const ceilingLight1 = new THREE.PointLight(0xffffff, 1.5, 10);
    ceilingLight1.position.set(-1.5, 5.5, -0.8);
    scene.add(ceilingLight1);

    const ceilingLight2 = new THREE.PointLight(0xffffff, 1.5, 10);
    ceilingLight2.position.set(1.5, 5.5, -0.8);
    scene.add(ceilingLight2);

    // === Blinking Light Bulb above TV ===
    const blinkLight = new THREE.PointLight(0xfff8d0, 2.2, 12, 2);
    blinkLight.position.set(0, 5.0, -3);
    blinkLight.castShadow = true;
    scene.add(blinkLight);

    // Cord
    const cordGeometry = new THREE.CylinderGeometry(0.038, 0.038, 0.16, 16);
    const cordMaterial = new THREE.MeshStandardMaterial({ color: 0xdddddd, metalness: 1, roughness: 0.2 });
    const cord = new THREE.Mesh(cordGeometry, cordMaterial);
    cord.position.set(0, 4.955, -3);
    scene.add(cord);

    // Bulb geometry
    const bulbPoints = [];
    bulbPoints.push(new THREE.Vector2(0,0));
    bulbPoints.push(new THREE.Vector2(0.057,0));
    bulbPoints.push(new THREE.Vector2(0.114,0.18));
    bulbPoints.push(new THREE.Vector2(0.133,0.38));
    bulbPoints.push(new THREE.Vector2(0.095,0.5));
    bulbPoints.push(new THREE.Vector2(0.057,0.55));
    bulbPoints.push(new THREE.Vector2(0,0.55));
    const bulbGeometry = new THREE.LatheGeometry(bulbPoints, 32);
    const bulbMaterial = new THREE.MeshStandardMaterial({
      color: 0xfff8d0,
      emissive: 0xfff8d0,
      emissiveIntensity: 2.2
    });
    const bulbMesh = new THREE.Mesh(bulbGeometry, bulbMaterial);
    bulbMesh.rotation.x = Math.PI;
    bulbMesh.scale.set(0.55, 0.55, 0.55);
    bulbMesh.position.set(0, 4.955, -3);
    scene.add(bulbMesh);

    // Metal base of bulb
    const bulbBaseGeometry = new THREE.CylinderGeometry(0.06, 0.06, 0.085, 32);
    const bulbBaseMaterial = new THREE.MeshStandardMaterial({ color: 0xeeeeee, metalness: 1, roughness: 0.2 });
    const bulbBase = new THREE.Mesh(bulbBaseGeometry, bulbBaseMaterial);
    bulbBase.position.set(0, 4.94, -3);
    scene.add(bulbBase);

    // === Walls & Floor ===
    const wallMaterial = new THREE.MeshStandardMaterial({ color: 0xcccaa0, roughness: 0.85 });
    const floorMaterial = new THREE.MeshStandardMaterial({
      color: 0x888877, roughness: 1, metalness: 0,
      map: new THREE.TextureLoader().load('https://threejs.org/examples/textures/floors/FloorsCheckerboard_S_Diffuse.jpg')
    });
    floorMaterial.map.wrapS = floorMaterial.map.wrapT = THREE.RepeatWrapping;
    floorMaterial.map.repeat.set(4, 4);

    const floor = new THREE.Mesh(new THREE.PlaneGeometry(10, 10), floorMaterial);
    floor.rotation.x = -Math.PI / 2;
    floor.receiveShadow = true;
    scene.add(floor);

    const wallGeometry = new THREE.PlaneGeometry(10, 5);
    const positions = [
      [0, 2.5, -5, 0],
      [0, 2.5, 5, Math.PI],
      [-5, 2.5, 0, Math.PI / 2],
      [5, 2.5, 0, -Math.PI / 2]
    ];
    positions.forEach(([x, y, z, ry]) => {
      const wall = new THREE.Mesh(wallGeometry, wallMaterial);
      wall.position.set(x, y, z);
      wall.rotation.y = ry;
      scene.add(wall);
    });

    // === Ceiling Panels ===
    const ceilingGroup = new THREE.Group();
    const ceilingTileMaterial = new THREE.MeshStandardMaterial({ color: 0xe4e4da, roughness: 0.85 });
    const lightPanelMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 2.8, roughness: 0.3 });
    const gridColor = 0xc8c8c8;
    const gridThickness = 0.02;
    const tileSize = 1;
    for (let x = -4.5; x <= 4.5; x += tileSize) {
      for (let z = -4.5; z <= 4.5; z += tileSize) {
        const isLightPanel = (Math.abs(x + 1.5) < 0.1 && Math.abs(z) < 0.1) || (Math.abs(x - 1.5) < 0.1 && Math.abs(z) < 0.1);
        const tileMaterial = isLightPanel ? lightPanelMaterial : ceilingTileMaterial;
        const tile = new THREE.Mesh(new THREE.BoxGeometry(tileSize - 0.04, 0.04, tileSize - 0.04), tileMaterial);
        tile.position.set(x, 5, z);
        ceilingGroup.add(tile);
        const frameX = new THREE.Mesh(new THREE.BoxGeometry(gridThickness, 0.045, tileSize), new THREE.MeshStandardMaterial({ color: gridColor }));
        frameX.position.set(x + tileSize / 2, 5, z);
        ceilingGroup.add(frameX);
        const frameZ = new THREE.Mesh(new THREE.BoxGeometry(tileSize, 0.045, gridThickness), new THREE.MeshStandardMaterial({ color: gridColor }));
        frameZ.position.set(x, 5, z + tileSize / 2);
        ceilingGroup.add(frameZ);
      }
    }
    scene.add(ceilingGroup);

    // === TV & Stand ===
    const tvGroup = new THREE.Group();
    const tvBody = new THREE.Mesh(new THREE.BoxGeometry(1.3, 1.15, 0.8), new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.4 }));
    tvBody.position.set(0, 1.475, -3);
    tvGroup.add(tvBody);

    const frame = new THREE.Mesh(new THREE.BoxGeometry(1.05, 0.75, 0.05), new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.4 }));
    frame.position.set(0, 1.55, -2.62);
    tvGroup.add(frame);

    const canvas = document.createElement('canvas');
    canvas.width = 256; canvas.height = 256;
    const ctx = canvas.getContext('2d');
    function drawStatic() {
      const imageData = ctx.createImageData(canvas.width, canvas.height);
      for (let i = 0; i < imageData.data.length; i += 4) {
        const shade = Math.random() * 255;
        imageData.data[i] = imageData.data[i + 1] = imageData.data[i + 2] = shade;
        imageData.data[i + 3] = 255;
      }
      ctx.putImageData(imageData, 0, 0);
    }
    const texture = new THREE.CanvasTexture(canvas);
    texture.minFilter = THREE.NearestFilter;
    texture.magFilter = THREE.NearestFilter;
    texture.generateMipmaps = false;

    const screen = new THREE.Mesh(new THREE.PlaneGeometry(0.9, 0.65), new THREE.MeshBasicMaterial({ map: texture }));
    screen.position.set(0, 1.55, -2.574);
    tvGroup.add(screen);

    const tvLight = new THREE.PointLight(0xffffff, 1.2, 6, 2);
    tvLight.position.set(0, 1.55, -2.574);
    scene.add(tvLight);

    const antennaMaterial = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 1, roughness: 0.2 });
    const antennaGeometry = new THREE.CylinderGeometry(0.02, 0.02, 1, 12);
    const ballGeometry = new THREE.SphereGeometry(0.038, 12, 12);
    const ballMaterial = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 1, roughness: 0.2 });
    const makeAntenna = (xOffset, zRot) => {
      const antenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
      antenna.position.set(xOffset, 1.85, -3);
      antenna.rotation.z = zRot;
      const ball = new THREE.Mesh(ballGeometry, ballMaterial);
      ball.position.set(0, 0.5, 0);
      antenna.add(ball);
      return antenna;
    };
    tvGroup.add(makeAntenna(-0.25, Math.PI / 10));
    tvGroup.add(makeAntenna(0.25, -Math.PI / 10));
    scene.add(tvGroup);

    const stand = new THREE.Mesh(new THREE.BoxGeometry(1.6, 0.5, 0.9), new THREE.MeshStandardMaterial({ color: 0x5b3a1e, roughness: 0.8 }));
    stand.position.set(0, 0.8, -3);
    stand.receiveShadow = true;
    scene.add(stand);

    const drawer = new THREE.Mesh(new THREE.BoxGeometry(1.4, 0.15, 0.02), new THREE.MeshStandardMaterial({ color: 0x6d4c2f, roughness: 0.7 }));
    drawer.position.set(0, 0.9, -2.56);
    drawer.receiveShadow = true;
    scene.add(drawer);

    const handle = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.2, 8), new THREE.MeshStandardMaterial({ color: 0x999999, metalness: 0.9 }));
    handle.rotation.z = Math.PI / 2;
    handle.position.set(0, 0.9, -2.54);
    scene.add(handle);

    const legGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.9, 8);
    const legMaterial = new THREE.MeshStandardMaterial({ color: 0x4a2d15, roughness: 0.8 });
    const legPositions = [[-0.75, 0.45, -2.55], [0.75, 0.45, -2.55], [-0.75, 0.45, -3.45], [0.75, 0.45, -3.45]];
    legPositions.forEach(pos => {
      const leg = new THREE.Mesh(legGeometry, legMaterial);
      leg.position.set(...pos);
      leg.receiveShadow = true;
      scene.add(leg);
    });

    // === Controls & Camera Lock ===
    let isDragging = false, prevMouse = { x: 0, y: 0 };
    const roomBounds = { xMin: -4.8, xMax: 4.8, yMin: 0.5, yMax: 5, zMin: -4.8, zMax: 4.8 };

    renderer.domElement.addEventListener('mousedown', e => { isDragging = true; prevMouse.x = e.clientX; prevMouse.y = e.clientY; });
    renderer.domElement.addEventListener('mouseup', () => isDragging = false);
    renderer.domElement.addEventListener('mousemove', e => {
      if (!isDragging) return;
      const dx = e.clientX - prevMouse.x;
      const dy = e.clientY - prevMouse.y;
      cameraAngle.y -= dx * 0.005;
      cameraAngle.x -= dy * 0.005;
      cameraAngle.x = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, cameraAngle.x));
      prevMouse.x = e.clientX; prevMouse.y = e.clientY;
    });

    renderer.domElement.addEventListener('touchstart', e => { if (e.touches.length === 1) { prevMouse.x = e.touches[0].clientX; prevMouse.y = e.touches[0].clientY; } }, { passive: true });
    renderer.domElement.addEventListener('touchmove', e => {
      if (e.touches.length === 1) {
        const dx = e.touches[0].clientX - prevMouse.x;
        const dy = e.touches[0].clientY - prevMouse.y;
        cameraAngle.y -= dx * 0.005;
        cameraAngle.x -= dy * 0.005;
        cameraAngle.x = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, cameraAngle.x));
        prevMouse.x = e.touches[0].clientX; prevMouse.y = e.touches[0].clientY;
      } else if (e.touches.length === 2) {
        const t0 = e.touches[0], t1 = e.touches[1];
        const pinchDist = Math.hypot(t0.clientX - t1.clientX, t0.clientY - t1.clientY);
        if (typeof lastPinchDist !== 'undefined') {
          const delta = (lastPinchDist - pinchDist) * 0.01;
          targetDistance += delta;
          targetDistance = Math.max(minDistance, Math.min(maxDistance, targetDistance));
        }
        lastPinchDist = pinchDist;
      }
    }, { passive: true });
    renderer.domElement.addEventListener('touchend', e => { delete lastPinchDist; });

    function changeTarget(delta) { targetDistance += delta; targetDistance = Math.max(minDistance, Math.min(maxDistance, targetDistance)); }
    document.getElementById('zoomIn').addEventListener('click', () => changeTarget(-0.6));
    document.getElementById('zoomOut').addEventListener('click', () => changeTarget(0.6));
    window.addEventListener('wheel', e => changeTarget(e.deltaY * 0.0025), { passive: true });

    // === Animation ===
    let flickerTime = 0, blinkTimer = 0;
    function flickerLights() {
      flickerTime += 0.05;
      const flicker = 1 + Math.sin(flickerTime * 3) * 0.05 + (Math.random() - 0.5) * 0.05;
      ceilingLight1.intensity = 1.5 * flicker;
      ceilingLight2.intensity = 1.5 * flicker;
      blinkTimer += 0.05;
      const intensity = 0.8 + Math.abs(Math.sin(blinkTimer * 2)) * 1.5;
      blinkLight.intensity = intensity;
      bulbMesh.material.emissiveIntensity = intensity;
      tvLight.intensity = 1.2 + Math.random() * 0.3;
    }

    const zoomLerpSpeed = 0.08;
    function animate() {
      requestAnimationFrame(animate);
      drawStatic();
      texture.needsUpdate = true;
      flickerLights();

      cameraDistance += (targetDistance - cameraDistance) * zoomLerpSpeed;
      const cosElev = Math.cos(cameraAngle.x);
      camera.position.x = cameraDistance * Math.sin(cameraAngle.y) * cosElev;
      camera.position.y = cameraDistance * Math.sin(cameraAngle.x) + 1.2;
      camera.position.z = cameraDistance * Math.cos(cameraAngle.y) * cosElev;

      // === Lock camera inside room ===
      camera.position.x = Math.max(roomBounds.xMin, Math.min(roomBounds.xMax, camera.position.x));
      camera.position.y = Math.max(roomBounds.yMin, Math.min(roomBounds.yMax, camera.position.y));
      camera.position.z = Math.max(roomBounds.zMin, Math.min(roomBounds.zMax, camera.position.z));

      camera.lookAt(0, 1.5, -3);
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
